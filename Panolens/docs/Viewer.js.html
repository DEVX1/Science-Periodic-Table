<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: viewer/Viewer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: viewer/Viewer.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>( function () {

	'use strict';

	/**
	 * Viewer contains pre-defined scene, camera and renderer
	 * @constructor
	 * @param {object} [options] - Use custom or default config options
	 * @param {HTMLElement} [options.container] - A HTMLElement to host the canvas
	 * @param {THREE.Scene} [options.scene=THREE.Scene] - A THREE.Scene which contains panorama and 3D objects
	 * @param {THREE.Camera} [options.camera=THREE.PerspectiveCamera] - A THREE.Camera to view the scene
	 * @param {THREE.WebGLRenderer} [options.renderer=THREE.WebGLRenderer] - A THREE.WebGLRenderer to render canvas
	 * @param {boolean} [options.controlBar=true] - Show/hide control bar on the bottom of the container
	 * @param {boolean} [options.autoHideControlBar=false] - Auto hide control bar when click on non-active area
	 * @param {boolean} [options.autoHideInfospot=false] - Auto hide infospots when click on non-active area
	 * @param {boolean} [options.horizontalView=false] - Allow only horizontal camera control
	 * @param {number}  [options.clickTolerance] - Distance tolerance to tigger click / tap event
	 */
	PANOLENS.Viewer = function ( options ) {

		THREE.EventDispatcher.call( this );
		
		if ( !THREE ) {

			console.error('Three.JS not found');

			return;
		}

		options = options || {};
		options.controlBar = options.controlBar !== undefined ? options.controlBar : true;
		options.autoHideControlBar = options.autoHideControlBar !== undefined ? options.autoHideControlBar : false;
		options.autoHideInfospot = options.autoHideInfospot !== undefined ? options.autoHideInfospot : true;
		options.horizontalView = options.horizontalView !== undefined ? options.horizontalView : false;
		options.clickTolerance = options.clickTolerance || 10;
		
		this.options = options;

		this.camera = options.camera || new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
		this.scene = options.scene || new THREE.Scene();
		this.renderer = options.renderer || new THREE.WebGLRenderer( { alpha: true, antialias: true } );
		this.effect;
		this.container;

		this.mode = PANOLENS.Modes.NORMAL;

		this.OrbitControls;
		this.DeviceOrientationControls;

		this.controls;
		this.panorama;
		this.widget;
		
		this.hoverObject;
		this.hoveringObject;
		this.pressEntityObject;
		this.pressObject;

		this.raycaster = new THREE.Raycaster();
		this.userMouse = new THREE.Vector2();
		this.updateCallbacks = [];
		this.DEBUG = false;

		// Renderer
		this.renderer.setPixelRatio( window.devicePixelRatio );
		this.renderer.setSize( window.innerWidth, window.innerHeight );
		this.renderer.setClearColor( 0x000000, 1 );

		// Container
		if ( options.container ) {

			this.container = options.container;

		} else {

			this.container = document.createElement('div');
			document.body.appendChild( this.container );

		}

		// Append Renderer Element to container
		this.renderer.domElement.classList.add( 'panolens-canvas' );
		this.container.appendChild( this.renderer.domElement );

		// Camera Controls
		this.OrbitControls = new THREE.OrbitControls( this.camera, this.container );
		this.OrbitControls.name = 'orbit';
		this.OrbitControls.minDistance = 1;
		this.OrbitControls.noPan = true;
		this.DeviceOrientationControls = new THREE.DeviceOrientationControls( this.camera );
		this.DeviceOrientationControls.name = 'device-orientation';

		// Cardboard effect
        this.effect = new THREE.CardboardEffect( this.renderer );
        this.effect.setSize( window.innerWidth, window.innerHeight );

		this.controls = [ this.OrbitControls, this.DeviceOrientationControls ];
		this.control = this.OrbitControls;
		
		// Lock horizontal view
		if ( this.options.horizontalView ) {
			this.OrbitControls.minPolarAngle = Math.PI / 2;
			this.OrbitControls.maxPolarAngle = Math.PI / 2;
		}

		// Add Control UI
		if ( this.options.controlBar !== false ) {
			this.addDefaultControlBar();
		}
		
		// Mouse / Touch Event
		this.container.addEventListener( 'mousedown', this.onMouseDown.bind( this ), true );
		this.container.addEventListener( 'mousemove', this.onMouseMove.bind( this ), true );
		this.container.addEventListener( 'mouseup', this.onMouseUp.bind( this ), true );
		this.container.addEventListener( 'touchstart', this.onMouseDown.bind( this ), true );
		this.container.addEventListener( 'touchend', this.onMouseUp.bind( this ), true );

		// Resize Event
		window.addEventListener( 'resize', this.onWindowResize.bind( this ), true );

		// Keyboard Event
		window.addEventListener( 'keydown', this.onKeyDown.bind( this ), true );
		window.addEventListener( 'keyup', this.onKeyUp.bind( this ), true );

		// Animate
		this.animate.call( this );

	}

	PANOLENS.Viewer.prototype = Object.create( THREE.EventDispatcher.prototype );

	PANOLENS.Viewer.prototype.constructor = PANOLENS.Viewer;

	PANOLENS.Viewer.prototype.add = function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i &lt; arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		this.scene.add( object );

		// All object added to scene has 'panolens-viewer-handler' event to handle viewer communication
		if ( object.addEventListener ) {

			object.addEventListener( 'panolens-viewer-handler', this.eventHandler.bind( this ) );

		}

		if ( object.type === 'panorama' ) {

			this.addPanoramaEventListener( object );

			if ( !this.panorama ) {

				this.setPanorama( object );

			}

		}

	};

	PANOLENS.Viewer.prototype.addDefaultControlBar = function () {

		if ( this.widget ) {

			console.warn( 'Default control bar exists' );
			return;

		}

		this.widget = new PANOLENS.Widget( this.container );
		this.widget.addEventListener( 'panolens-viewer-handler', this.eventHandler.bind( this ) );
		this.widget.addDefaultControlBar();

	};

	PANOLENS.Viewer.prototype.setPanorama = function ( pano ) {

		if ( pano.type === 'panorama' ) {
			
			// Reset Current Panorama
			this.panorama &amp;&amp; this.panorama.onLeave();

			// Assign and enter panorama
			(this.panorama = pano).onEnter();
			
		}

	};

	PANOLENS.Viewer.prototype.eventHandler = function ( event ) {

		if ( event.method &amp;&amp; this[ event.method ] ) {

			this[ event.method ]( event.data );

		}

	};

	PANOLENS.Viewer.prototype.toggleVR = function () {

		if ( this.effect ) {

			if ( this.mode !== PANOLENS.Modes.VR ) {

				this.enableVR();

			} else {

				this.disableVR();

			}
		}

		this.dispatchEvent( { type: 'VR-toggle', mode: this.mode } );

	};

	PANOLENS.Viewer.prototype.enableVR = function () {

		if ( this.effect &amp;&amp; this.mode !== PANOLENS.Modes.VR ) {

			this.mode = PANOLENS.Modes.VR;

		}

	};

	PANOLENS.Viewer.prototype.disableVR = function () {

		if ( this.effect &amp;&amp; this.mode !== PANOLENS.Modes.NORMAL ) {

			this.mode = PANOLENS.Modes.NORMAL;

		}

	};

	PANOLENS.Viewer.prototype.toggleVideoPlay = function () {

		if ( this.panorama instanceof PANOLENS.VideoPanorama ) {

			this.panorama.dispatchEvent( { type: 'video-toggle' } );

		}

	};

	PANOLENS.Viewer.prototype.setVideoCurrentTime = function ( percentage ) {

		if ( this.panorama instanceof PANOLENS.VideoPanorama ) {

			this.panorama.dispatchEvent( { type: 'video-time', percentage: percentage } );

		}

	};

	PANOLENS.Viewer.prototype.onVideoUpdate = function ( percentage ) {

		this.widget &amp;&amp; this.widget.dispatchEvent( { type: 'video-update', percentage: percentage } );

	};

	PANOLENS.Viewer.prototype.addUpdateCallback = function ( fn ) {

		if ( fn ) {

			this.updateCallbacks.push( fn );

		}

	};

	PANOLENS.Viewer.prototype.removeUpdateCallback = function ( fn ) {

		var index = this.updateCallbacks.indexOf( fn );

		if ( fn &amp;&amp; index >= 0 ) {

			this.updateCallbacks.splice( index, 1 );

		}

	};

	PANOLENS.Viewer.prototype.showVideoWidget = function () {

		this.widget &amp;&amp; this.widget.dispatchEvent( { type: 'video-control-show' } );

	};

	PANOLENS.Viewer.prototype.hideVideoWidget = function () {

		this.widget &amp;&amp; this.widget.dispatchEvent( { type: 'video-control-hide' } );

	};

	PANOLENS.Viewer.prototype.addPanoramaEventListener = function ( pano ) {

		// Every panorama
		pano.addEventListener( 'enter-start', this.setCameraControl.bind( this ) );

		// VideoPanorama
		if ( pano instanceof PANOLENS.VideoPanorama ) {

			pano.addEventListener( 'enter', this.showVideoWidget.bind( this ) );
			pano.addEventListener( 'leave', this.hideVideoWidget.bind( this ) );

		}


	};

	PANOLENS.Viewer.prototype.setCameraControl = function () {

		this.camera.position.copy( this.panorama.position );
		this.camera.position.z += 1;
		this.OrbitControls.target.copy( this.panorama.position );

	};

	PANOLENS.Viewer.prototype.getControl = function () {

		return this.control;

	},

	PANOLENS.Viewer.prototype.getScene = function () {

		return this.scene;

	};

	PANOLENS.Viewer.prototype.getCamera = function () {

		return this.camera;

	},

	PANOLENS.Viewer.prototype.getRenderer = function () {

		return this.renderer;

	};

	PANOLENS.Viewer.prototype.getContainer = function () {

		return this.container;

	};

	PANOLENS.Viewer.prototype.getControlName = function () {

		return this.control.name;

	};

	PANOLENS.Viewer.prototype.getNextControlName = function () {

		return this.controls[ this.getNextControlIndex() ].name;

	};

	PANOLENS.Viewer.prototype.getNextControlIndex = function () {

		return ( this.controls.indexOf( this.control ) + 1 >= this.controls.length ) ? 0 : this.controls.indexOf( this.control ) + 1;

	};

	PANOLENS.Viewer.prototype.enableControl = function ( index ) {

		index = ( index >= 0 &amp;&amp; index &lt; this.controls.length ) ? index : 0;

		this.control.enabled = false;

		this.control = this.controls[ index ];

		this.control.enabled = true;

		switch ( this.control.name ) {
			case 'orbit':
				this.camera.position.copy( this.panorama.position );
				this.camera.position.z += 1;
				break;
			case 'device-orientation':
				this.camera.position.copy( this.panorama.position );
				break;
			default:
				break;
		}

	};

	PANOLENS.Viewer.prototype.toggleNextControl = function () {

		this.enableControl( this.getNextControlIndex() );

	};

	PANOLENS.Viewer.prototype.onWindowResize = function () {

		this.camera.aspect = window.innerWidth / window.innerHeight;
		this.camera.updateProjectionMatrix();

		this.renderer.setSize( window.innerWidth, window.innerHeight );

		this.dispatchEvent( { type: 'window-resize', width: window.innerWidth, height: window.innerHeight })
	};

	PANOLENS.Viewer.prototype.render = function () {

		TWEEN.update();
		this.updateCallbacks.forEach( function( callback ){ callback(); } );
		this.control &amp;&amp; this.control.update();
		
		if ( this.mode === PANOLENS.Modes.VR ) {

			this.effect.render( this.scene, this.camera );

		} else {

			this.renderer.render( this.scene, this.camera );

		}

	};

	PANOLENS.Viewer.prototype.onMouseDown = function ( event ) {

		event.preventDefault();

		this.userMouse.x = ( event.clientX ) ? event.clientX : event.touches[0].clientX;
		this.userMouse.y = ( event.clientY ) ? event.clientY : event.touches[0].clientY;
		this.userMouse.type = 'mousedown';
		this.onTap( event );

	};

	PANOLENS.Viewer.prototype.onMouseMove = function ( event ) {

		event.preventDefault();
		this.userMouse.type = 'mousemove';
		this.onTap( event );

	};

	PANOLENS.Viewer.prototype.onMouseUp = function ( event ) {

		var onTarget = false, type;

		this.userMouse.type = 'mouseup';

		type = ( this.userMouse.x >= event.clientX - this.options.clickTolerance 
				&amp;&amp; this.userMouse.x &lt;= event.clientX + this.options.clickTolerance
				&amp;&amp; this.userMouse.y >= event.clientY - this.options.clickTolerance
				&amp;&amp; this.userMouse.y &lt;= event.clientY + this.options.clickTolerance ) 
				||  ( event.changedTouches 
				&amp;&amp; this.userMouse.x >= event.changedTouches[0].clientX - this.options.clickTolerance
				&amp;&amp; this.userMouse.x &lt;= event.changedTouches[0].clientX + this.options.clickTolerance 
				&amp;&amp; this.userMouse.y >= event.changedTouches[0].clientY - this.options.clickTolerance
				&amp;&amp; this.userMouse.y &lt;= event.changedTouches[0].clientY + this.options.clickTolerance ) 
		? 'click' : undefined;

		// Event should happen on canvas
		if ( event &amp;&amp; event.target &amp;&amp; !event.target.classList.contains( 'panolens-canvas' ) ) { return; }

		event.preventDefault();

		if ( event.changedTouches &amp;&amp; event.changedTouches.length === 1 ) {

			onTarget = this.onTap( { clientX : event.changedTouches[0].clientX, clientY : event.changedTouches[0].clientY }, type );
		
		} else {

			onTarget = this.onTap( event, type );

		}

		this.userMouse.type = 'none';

		if ( onTarget ) { 

			return; 

		}

		if ( type === 'click' ) {

			this.options.autoHideInfospot &amp;&amp; this.panorama &amp;&amp; this.panorama.toggleChildrenVisibility();
			this.options.autoHideControlBar &amp;&amp; toggleControlBar();

		}

	};

	PANOLENS.Viewer.prototype.onTap = function ( event, type ) {

		var point = {}, object, intersects, intersect_entity, intersect;

		point.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		point.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		this.raycaster.setFromCamera( point, this.camera );

		if ( !this.panorama ) { return; }

		// For Adding Infospot
		if ( this.DEBUG ) {

			intersects = this.raycaster.intersectObject( this.panorama, true );

			if ( intersects.length > 0 ) {

				intersects[0].point.applyAxisAngle( new THREE.Vector3( -1, 0, 0 ), this.panorama.rotation.x );
				intersects[0].point.applyAxisAngle( new THREE.Vector3( 0, -1, 0 ), this.panorama.rotation.y );
				intersects[0].point.applyAxisAngle( new THREE.Vector3( 0, 0, -1 ), this.panorama.rotation.z );

				intersects[0].point.sub( this.panorama.position );

				console.info('{ ' + (-intersects[0].point.x).toFixed(2) + 
					', ' + (intersects[0].point.y).toFixed(2) +
					', ' + (intersects[0].point.z).toFixed(2) + ' }'
				);

			}
			
		}

		intersects = this.raycaster.intersectObjects( this.panorama.children, true );

		intersect_entity = this.getConvertedIntersect( intersects );

		intersect = ( intersects.length > 0 ) ? intersects[0].object : intersect;

		if ( this.userMouse.type === 'mouseup'  ) {

			if ( intersect_entity &amp;&amp; this.pressEntityObject === intersect_entity &amp;&amp; this.pressEntityObject.dispatchEvent ) {

				this.pressEntityObject.dispatchEvent( { type: 'pressstop-entity', mouseEvent: event } );

			}

			this.pressEntityObject = undefined;

		}

		if ( this.userMouse.type === 'mouseup'  ) {

			if ( intersect &amp;&amp; this.pressObject === intersect &amp;&amp; this.pressObject.dispatchEvent ) {

				this.pressObject.dispatchEvent( { type: 'pressstop', mouseEvent: event } );

			}

			this.pressObject = undefined;

		}

		if ( type === 'click' ) {

			this.panorama.dispatchEvent( { type: 'click', intersects: intersects, mouseEvent: event } );

			if ( intersect_entity &amp;&amp; intersect_entity.dispatchEvent ) {

				intersect_entity.dispatchEvent( { type: 'click-entity', mouseEvent: event } );

			}

			if ( intersect &amp;&amp; intersect.dispatchEvent ) {

				intersect.dispatchEvent( { type: 'click', mouseEvent: event } );

			}

		} else {

			this.panorama.dispatchEvent( { type: 'hover', intersects: intersects, mouseEvent: event } );

			if ( ( this.hoverObject &amp;&amp; intersects.length > 0 &amp;&amp; this.hoverObject !== intersect_entity )
				|| ( this.hoverObject &amp;&amp; intersects.length === 0 ) ){

				if ( this.hoverObject.dispatchEvent ) {

					this.hoverObject.dispatchEvent( { type: 'hoverleave', mouseEvent: event } );

				}

				this.hoverObject = undefined;

			}

			if ( intersect_entity &amp;&amp; intersects.length > 0 ) {

				if ( this.hoverObject !== intersect_entity ) {

					this.hoverObject = intersect_entity;

					if ( this.hoverObject.dispatchEvent ) {

						this.hoverObject.dispatchEvent( { type: 'hoverenter', mouseEvent: event } );

					}

				}

				if ( this.userMouse.type === 'mousedown' &amp;&amp; this.pressEntityObject != intersect_entity ) {

					this.pressEntityObject = intersect_entity;

					if ( this.pressEntityObject.dispatchEvent ) {

						this.pressEntityObject.dispatchEvent( { type: 'pressstart-entity', mouseEvent: event } );

					}

				}

				if ( this.userMouse.type === 'mousedown' &amp;&amp; this.pressObject != intersect ) {

					this.pressObject = intersect;

					if ( this.pressObject.dispatchEvent ) {

						this.pressObject.dispatchEvent( { type: 'pressstart', mouseEvent: event } );

					}

				}

				if ( this.userMouse.type === 'mousemove' ) {

					if ( this.pressEntityObject &amp;&amp; this.pressEntityObject.dispatchEvent ) {

						this.pressEntityObject.dispatchEvent( { type: 'pressmove-entity', mouseEvent: event } );

					}

					if ( this.pressObject &amp;&amp; this.pressObject.dispatchEvent ) {

						this.pressObject.dispatchEvent( { type: 'pressmove', mouseEvent: event } );

					}

				}

			}

			if ( !intersect_entity &amp;&amp; this.pressEntityObject &amp;&amp; this.pressEntityObject.dispatchEvent ) {

				this.pressEntityObject.dispatchEvent( { type: 'pressstop-entity', mouseEvent: event } );

				this.pressEntityObject = undefined;

			}

			if ( !intersect &amp;&amp; this.pressObject &amp;&amp; this.pressObject.dispatchEvent ) {

				this.pressObject.dispatchEvent( { type: 'pressstop', mouseEvent: event } );

				this.pressObject = undefined;

			}

		}

		if ( intersects.length > 0 &amp;&amp; intersects[ 0 ].object instanceof PANOLENS.Infospot ) {

			object = intersects[ 0 ].object;

			if ( object.onHover ) {

				this.hoveringObject = object;

				this.container.style.cursor = 'pointer';

				object.onHover( event.clientX, event.clientY );

			}

			if ( type === 'click' &amp;&amp; object.onClick ) {

				object.onClick();

				return true;

			}

		} else {

			this.container.style.cursor = 'default';

			this.hideHoveringObject();

		}

	};

	PANOLENS.Viewer.prototype.getConvertedIntersect = function ( intersects ) {

		var intersect;

		for ( var i = 0; i &lt; intersects.length; i++ ) {

			if ( intersects[i].object &amp;&amp; !intersects[i].object.passThrough ) {

				if ( intersects[i].object.entity &amp;&amp; intersects[i].object.entity.passThrough ) {
					continue;
				} else if ( intersects[i].object.entity &amp;&amp; !intersects[i].object.entity.passThrough ) {
					intersect = intersects[i].object.entity;
					break;
				} else {
					intersect = intersects[i].object;
					break;
				}

			}

		}

		return intersect;

	};

	PANOLENS.Viewer.prototype.hideHoveringObject = function ( intersects ) {

		if ( this.hoveringObject ) {

			this.hoveringObject.onHoverEnd();

			this.hoveringObject = undefined;

		}

	};

	PANOLENS.Viewer.prototype.toggleControlBar = function () {

		widget &amp;&amp; widget.dispatchEvent( { type: 'control-bar-toggle' } );

	};

	PANOLENS.Viewer.prototype.onKeyDown = function ( event ) {

		if ( event.keyCode === 17 || event.keyIdentifier === 'Control' ) {

			this.DEBUG = true;

		}

	};

	PANOLENS.Viewer.prototype.onKeyUp = function ( event ) {

		this.DEBUG = false;

	};

	PANOLENS.Viewer.prototype.animate = function () {

		window.requestAnimationFrame( this.animate.bind( this ) );

        this.render();

	};

} )();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="PANOLENS.CubePanorama.html">CubePanorama</a></li><li><a href="PANOLENS.EmptyPanorama.html">EmptyPanorama</a></li><li><a href="PANOLENS.GoogleStreetviewPanorama.html">GoogleStreetviewPanorama</a></li><li><a href="PANOLENS.ImagePanorama.html">ImagePanorama</a></li><li><a href="PANOLENS.Infospot.html">Infospot</a></li><li><a href="PANOLENS.Panorama.html">Panorama</a></li><li><a href="PANOLENS.Tile.html">Tile</a></li><li><a href="PANOLENS.Viewer.html">Viewer</a></li><li><a href="PANOLENS.Widget.html">Widget</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Sun Feb 28 2016 16:55:56 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
